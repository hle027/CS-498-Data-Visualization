<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
font-family: Arial;
font: 13px sans-serif;
}
h1{
 font-family: Arial, Helvetica, sans-serif;
 text-align:center;
}
/* Style the tab */
.tab {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

/* Style the buttons inside the tab */
.tab button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
    font-size: 17px;
}

/* Change background color of buttons on hover */
.tab button:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
.tab button.active {
    background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
    display: none;
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-top: none;
}

#tooltip {
        opacity: 0;
        position: absolute;
        text-align: center;
        width: 100px;
        height: 60px;
        background-color: rgba(220, 220, 220, 1);
        color: #333;
        -webkit-border-radius: 20px;
        -moz-border-radius: 20px;
        border-radius: 20px;
    }


    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .layer text {
        text-anchor: end;
    }
	
	svg {
        font: 10px sans-serif;
    }

    .tooltip {

        background-color: rgba(220, 220, 220, 1);
        color: #333;
        margin: 10px;
        height: 25px;
        padding-right: 10px;
        padding-left: 10px;
        padding-top: 10px;
        -webkit-border-radius: 20px;
        -moz-border-radius: 20px;
        border-radius: 20px;
    }


    .background path {
        fill: none;
        stroke: #ccc;
        stroke-opacity: .4;
        shape-rendering: crispEdges;
    }

    .foreground path {
        fill: none;
        stroke: steelblue;
        stroke-opacity: .7;
    }

    .brush .extent {
        fill-opacity: .3;
        stroke: #fff;
        shape-rendering: crispEdges;
    }

    .axis line,
    .axis path {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .axis text {
        text-shadow: 0 1px 0 #fff;
        cursor: move;
    }
	
ul,ol,dl,p {
  font-size: 1rem;
}

li, p {
  line-height: 1.5;
}

p {
	text-indent: 3em;
}

</style>
<script src="https://d3js.org/d3.v3.min.js"></script>
</head>
<body>
<h1>Data Visualization - Final Project</h1>

<p>Click on the buttons inside the tabbed menu:</p>

<div class="tab">
	<button class="tablinks" onclick="openVisualization(event, 'Overview')">About the Visualization</button>
	<button class="tablinks" onclick="openVisualization(event, 'AreaChart')">Property Prices Analysis</button>
	<button class="tablinks" onclick="openVisualization(event, 'ParallelCoords')">Multidimentional Analysis</button>
</div>

<div id="Overview" class="tabcontent">
   <ul>
      <li>
         Does the narrative visualization correctly follow the hybrid structure as stated by the essay?
         <p>The narrative visualization follows the Martini glass structure. Initially a stacked area chart is present by clicking on "Property Prices Analysis" where the y axis has the value of given property per city
            and the x axis represents the years 2012-2018 during which the data was collected. On the other side, the "Multidimentional Analysis" shows some correlations between 8 dimentions of the data.
            Both visualizations have an element of the drill-down which is the tooltip displayed once hovering over given color(the area chart) or given line (the parallel coordinates chart).
            However, for both of them initially the data is presented(the bottom of the Martini glass) and the user can operate further	hovering, brushing or selecting data elements.	
         </p>
      </li>
      <li>
         Does the narrative visualization effectively utilize scenes?
         <p>There are three scenes in total. The first is the overview/description, which may not count as a real scene although it is still part of the state machine playing the role of initial state-
            the state the user is initially landing on. The next two tabs- stacked area chart and parallel coordinates are the real scenes giving meaningful data and correlation regarding the 
            data problem and questions the visualizations are trying to solve. Every scene is following common template for visual consistency. 
         </p>
         <p>The area chart has animation which is triggered on page load and is not controlled by the user. 
            The colors are picked so that they clearly distinguish the different cities which effect is even emphasized by the animation. By hovering over a given color it drills-down for more
            detailed information.
         </p>
         <p>The parallel coordinates chart gives the ability to the user to select one or more lines and the visualization highlights them so that it is easier to track their correlation
            and how different attributes influence the others. Moreover, once hovered given line becomes red and tooltip with the corresponding price is shown.
         </p>
      </li>
      <li>
         Does the narrative visualization effectively utilize annotations?
         <p> On the first visualization for every stacked color there is a city name on the right-hand side that clearly displays which city corresponds to this particular color.
			Looking at the multidimentional analysis all the eight dimentions are annotated showing their names.
		 </p>
      </li>
      <li>
         Does the narrative visualization effectively utilize parameters?
         <p> The transition between different scenes and visualization is done based on click on a partucular tab. If we consider the web page as state machine these tabs
            are user driven parameters which change the states. 
         </p>
      </li>
      <li>
         Does the narrative visualization effectively utilize triggers?
         <p>When the user selects line/s from the multidimentional graph this triggers an event which highlights only the selected lines. For both visualizations there is hover event bound
			that triggers a tooltip. In the case of the parallel coordinates the hover even highlights the line making its color red.
		 </p>
      </li>
   </ul>
</div>

<div id="AreaChart" class="tabcontent">
  <div id="tooltip"></div>
  <script>
  var areaChart={
  display: function () {
        var margin = {
                top: 20,
                right: 20,
                bottom: 30,
                left: 100
            },
            width = 960 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;

        var parseDate = d3.time.format("%m/%d/%Y").parse;


        var x = d3.time.scale()
            .range([0, width]);

        var y = d3.scale.linear()
            .range([height, 0]);

        var color = d3.scale.category20();

        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        var area = d3.svg.area()
            .x(function(d) {
                return x(d.PeriodBegin);
            })
            .y0(function(d) {
                return y(d.y0);
            })
            .y1(function(d) {
                return y(d.y0 + d.y);
            });

        var x2 = d3.time.scale().range([0, width]);

        var stack = d3.layout.stack()
            .values(function(d) {
                return d.values;
            });

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        function brushed() {
            x.domain(brush.empty() ? x2.domain() : brush.extent());
            focus.selectAll("path.focus").attr("d", function(d) {
                return area(d.values)
            });
            focus.select(".x.axis").call(xAxis);
        }
        var brush = d3.svg.brush()
            .x(x2)
            .on("brush", brushed);
        var tooltip = d3.select("#tooltip");


        d3.csv("https://raw.githubusercontent.com/yan6pz/DataVisualization/master/PropertyPrices.csv", function(error, data) {
            color.domain(d3.keys(data[0]).filter(function(key) {
                return key !== "PeriodBegin";
            }));
            data.forEach(function(d) {
                d.PeriodBegin = parseDate(d.PeriodBegin);
            });

            var layers = stack(color.domain().map(function(name) {
                var result = {
                    name: name,
                    values: data.map(function(d) {
                        return {
                            PeriodBegin: d.PeriodBegin,
                            y: parseFloat(d[name]) * 1,
                            y0: 0
                        };
                    })
                };
                return result;
            }));

            // Find the value of the day with highest total value
            var maxDateVal = d3.max(data, function(d) {
                var vals = d3.keys(d).map(function(key) {
                    return key !== "PeriodBegin" ? parseFloat(d[key]) : 0
                });
                return d3.sum(vals);
            });

            // Set domains for axes
            x.domain(d3.extent(data, function(d) {
                return d.PeriodBegin;
            }));
            y.domain([0, maxDateVal]);



            var layer = svg.selectAll(".layer")
                .data(layers)
                .enter().append("g")
                .attr("class", "layer")
                .on("mouseover", function(d, i) {
                    tooltip.style("opacity", 1)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY) + "px")
                        .html("The mean property price of " + d.name + " is $" + parseInt(d.values.map(function(a) {
                            return a.y;
                        }).reduce((a, b) => a + b, 0) / d.values.length));
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0)
                });

            layer.append("path")
                .attr("class", "area")
                .transition()
                .delay(function(d, i) {
                    return i * 1000;
                })
                .duration(1000)
                .attr("d", function(d) {
                    return area(d.values);
                })
                .style("fill", function(d) {
                    return color(d.name);
                });

            layer.append("text")
                .datum(function(d) {
                    return {
                        name: d.name,
                        value: d.values[d.values.length - 1]
                    };
                })
                .attr("transform", function(d) {
                    return "translate(" + x(d.value.PeriodBegin) + "," + y(d.value.y0 + d.value.y / 6) + ")";
                })
                .attr("x", -6)
                .attr("dy", ".35em")
                .text(function(d) {
                    return d.name;
                });

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            svg.append("g")
                .attr("class", "y axis")
                .call(d3.svg.axis()
                    .scale(y)
                    .orient("left"));
        });
		}};
    </script>
</div>

<div id="ParallelCoords" class="tabcontent">
      <script>
	  var multiDimantional={
	  
	  display: function () {
        var tooltip = d3.select("body")
            .append("div")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .text("a simple tooltip")
            .attr("class", "tooltip");

        var m = [30, 10, 10, 10],
            w = 1060 - m[1] - m[3],
            h = 600 - m[0] - m[2];

        var x = d3.scale.ordinal().rangePoints([0, w], 1),
            y = {},
            dragging = {};

        var line = d3.svg.line(),
            axis = d3.svg.axis().orient("left"),
            background,
            foreground;

        var svg = d3.select("body").append("svg")
            .attr("width", w + m[1] + m[3])
            .attr("height", h + m[0] + m[2])
            .append("g")
            .attr("transform", "translate(" + m[3] + "," + m[0] + ")");


        d3.csv("https://raw.githubusercontent.com/yan6pz/DataVisualization/master/PropertySales.csv", function(error, propertySales) {

            // Extract the list of dimensions and create a scale for each different than the city.
            x.domain(dimensions = d3.keys(propertySales[0]).filter(function(d) {
                return d != "Region" && (y[d] = d3.scale.linear()
                    .domain(d3.extent(propertySales, function(p) {
                        return +p[d];
                    }))
                    .range([h, 0]));
            }));

            // Add grey background lines for context. Draw the lines based on the dimensions of the path function.
            background = svg.append("g")
                .attr("class", "background")
                .selectAll("path")
                .data(propertySales)
                .enter().append("path")
                .attr("d", path);

            // Add blue foreground lines for focus. Draw the lines based on the dimensions of the path function and add tooltip.
            foreground = svg.append("g")
                .attr("class", "foreground")
                .selectAll("path")
                .data(propertySales)
                .enter().append("path")
                .attr("d", path).on("mouseover", function(n) {
                    d3.select(this).transition().duration(100)
                        .style({
                            'stroke': '#F00'
                        });
                    tooltip.text(n.Region + " Median List Price: $" + n["Median List Price"]);
                    return tooltip.style("visibility", "visible");
                })
                .on("mousemove", function() {
                    return tooltip.style("top", (event.pageY - 10) + "px").style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function(d) {
                    d3.select(this).transition().duration(100)
                        .style({
                            'stroke': 'steelblue'
                        })
                        .style({
                            'stroke-width': '2'
                        });
                    return tooltip.style("visibility", "hidden");
                });

            // Add a group element for each dimension.
            var g = svg.selectAll(".dimension")
                .data(dimensions)
                .enter().append("g")
                .attr("class", "dimension")
                .attr("transform", function(d) {
                    return "translate(" + x(d) + ")";
                })
                .call(d3.behavior.drag()
                    .on("dragstart", function(d) {
                        dragging[d] = this.__origin__ = x(d);
                        background.attr("visibility", "hidden");
                    })
                    .on("drag", function(d) {
                        dragging[d] = Math.min(w, Math.max(0, this.__origin__ += d3.event.dx));
                        foreground.attr("d", path);
                        dimensions.sort(function(a, b) {

                            return position(a) - position(b);
                        });
                        x.domain(dimensions);
                        g.attr("transform", function(d) {

                            return "translate(" + position(d) + ")";
                        })
                    })
                    .on("dragend", function(d) {
                        delete this.__origin__;
                        delete dragging[d];
                        transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
                        transition(foreground)
                            .attr("d", path);
                        background
                            .attr("d", path)
                            .transition()
                            .delay(500)
                            .duration(10)
                            .attr("visibility", null);
                    })
                );

            // Add an axis and title.
            g.append("g")
                .attr("class", "axis")
                .each(function(d) {
                    d3.select(this).call(axis.scale(y[d]));
                })
                .append("text")
                .attr("text-anchor", "middle")
                .attr("y", -9)
                .text(String);

            // Add and store a brush for each axis.
            g.append("g")
                .attr("class", "brush")
                .each(function(d) {
                    d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
                })
                .selectAll("rect")
                .attr("x", -8)
                .attr("width", 16);
        });

        function position(d) {
            var v = dragging[d];
            return v == null ? x(d) : v;
        }

        function transition(g) {
            return g.transition().duration(1000);
        }

        // Returns the path for a given data point. Per every dimension get start point and endpoint for the line.
        function path(d) {
            return line(dimensions.map(function(p) {
                return [position(p), y[p](d[p])];
            }));
        }

        // When brushing, don’t trigger axis dragging.
        function brushstart() {
            d3.event.sourceEvent.stopPropagation();
        }

        // Handles a brush event, toggling the display of foreground lines.
        function brush() {
            var actives = dimensions.filter(function(p) {
                    return !y[p].brush.empty();
                }),
                extents = actives.map(function(p) {
                    return y[p].brush.extent();
                });
            foreground.style("display", function(d) {
                return actives.every(function(p, i) {
                    return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                }) ? null : "none";
            });
        }
		}};
    </script>
</div>

<script>
function openVisualization(evt, visName) {
    var i, tabcontent, tablinks;
	d3.select("svg").remove();
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
		if(visName!=='Overview')
			tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(visName).style.display = "block";
	if(evt!==0)
		evt.currentTarget.className += " active";
		
	if(visName==='ParallelCoords')
		multiDimantional.display();
	if(visName==='AreaChart')
		areaChart.display();
	if(visName==='Overview')
		tablinks[evt].className = tablinks[evt].className += " active";
}
openVisualization(0,'Overview');
</script>
     
</body>
</html> 
